/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { BaseContract, BigNumber, BigNumberish, CallOverrides, ContractTransaction, ethers, Overrides, PayableOverrides, PopulatedTransaction, Signer } from 'ethers'
import { BytesLike } from '@ethersproject/bytes'
import { Listener, Provider } from '@ethersproject/providers'
import { EventFragment, FunctionFragment, Result } from '@ethersproject/abi'
import type { TypedEvent, TypedEventFilter, TypedListener } from './common'

interface FarmingCenterInterface extends ethers.utils.Interface {
    functions: {
        'DOMAIN_SEPARATOR()': FunctionFragment;
        'PERMIT_TYPEHASH()': FunctionFragment;
        'approve(address,uint256)': FunctionFragment;
        'balanceOf(address)': FunctionFragment;
        'baseURI()': FunctionFragment;
        'claimReward(address,address,uint256,uint256)': FunctionFragment;
        'collectFees((uint256,address,uint128,uint128))': FunctionFragment;
        'collectRewards((address,address,address,uint256,uint256),uint256)': FunctionFragment;
        'cross(int24,bool)': FunctionFragment;
        'deposits(uint256)': FunctionFragment;
        'enterEternalFarming((address,address,address,uint256,uint256),uint256)': FunctionFragment;
        'enterFarming((address,address,address,uint256,uint256),uint256)': FunctionFragment;
        'eternalFarming()': FunctionFragment;
        'exitEternalFarming((address,address,address,uint256,uint256),uint256)': FunctionFragment;
        'exitFarming((address,address,address,uint256,uint256),uint256)': FunctionFragment;
        'farming()': FunctionFragment;
        'getApproved(uint256)': FunctionFragment;
        'increaseCumulative(uint32)': FunctionFragment;
        'isApprovedForAll(address,address)': FunctionFragment;
        'l2Nfts(uint256)': FunctionFragment;
        'multicall(bytes[])': FunctionFragment;
        'name()': FunctionFragment;
        'nonfungiblePositionManager()': FunctionFragment;
        'onERC721Received(address,address,uint256,bytes)': FunctionFragment;
        'ownerOf(uint256)': FunctionFragment;
        'permit(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
        'processSwap()': FunctionFragment;
        'safeTransferFrom(address,address,uint256)': FunctionFragment;
        'setApprovalForAll(address,bool)': FunctionFragment;
        'setFarmingCenterAddress(address,address)': FunctionFragment;
        'supportsInterface(bytes4)': FunctionFragment;
        'symbol()': FunctionFragment;
        'tokenByIndex(uint256)': FunctionFragment;
        'tokenOfOwnerByIndex(address,uint256)': FunctionFragment;
        'tokenURI(uint256)': FunctionFragment;
        'totalSupply()': FunctionFragment;
        'transferFrom(address,address,uint256)': FunctionFragment;
        'virtualPoolAddresses(address)': FunctionFragment;
        'withdrawToken(uint256,address,bytes)': FunctionFragment;
    };
    events: {
        'Approval(address,address,uint256)': EventFragment;
        'ApprovalForAll(address,address,bool)': EventFragment;
        'DepositTransferred(uint256,address,address)': EventFragment;
        'Transfer(address,address,uint256)': EventFragment;
    };

    encodeFunctionData(
        functionFragment: 'DOMAIN_SEPARATOR',
        values?: undefined
    ): string;

    encodeFunctionData(
        functionFragment: 'PERMIT_TYPEHASH',
        values?: undefined
    ): string;

    encodeFunctionData(
        functionFragment: 'approve',
        values: [string, BigNumberish]
    ): string;

    encodeFunctionData(functionFragment: 'balanceOf', values: [string]): string;

    encodeFunctionData(functionFragment: 'baseURI', values?: undefined): string;

    encodeFunctionData(
        functionFragment: 'claimReward',
        values: [string, string, BigNumberish, BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'collectFees',
        values: [
            {
                tokenId: BigNumberish;
                recipient: string;
                amount0Max: BigNumberish;
                amount1Max: BigNumberish;
            }
        ]
    ): string;

    encodeFunctionData(
        functionFragment: 'collectRewards',
        values: [
            {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            BigNumberish
        ]
    ): string;

    encodeFunctionData(
        functionFragment: 'cross',
        values: [BigNumberish, boolean]
    ): string;

    encodeFunctionData(
        functionFragment: 'deposits',
        values: [BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'enterEternalFarming',
        values: [
            {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            BigNumberish
        ]
    ): string;

    encodeFunctionData(
        functionFragment: 'enterFarming',
        values: [
            {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            BigNumberish
        ]
    ): string;

    encodeFunctionData(
        functionFragment: 'eternalFarming',
        values?: undefined
    ): string;

    encodeFunctionData(
        functionFragment: 'exitEternalFarming',
        values: [
            {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            BigNumberish
        ]
    ): string;

    encodeFunctionData(
        functionFragment: 'exitFarming',
        values: [
            {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            BigNumberish
        ]
    ): string;

    encodeFunctionData(functionFragment: 'farming', values?: undefined): string;

    encodeFunctionData(
        functionFragment: 'getApproved',
        values: [BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'increaseCumulative',
        values: [BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'isApprovedForAll',
        values: [string, string]
    ): string;

    encodeFunctionData(
        functionFragment: 'l2Nfts',
        values: [BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'multicall',
        values: [BytesLike[]]
    ): string;

    encodeFunctionData(functionFragment: 'name', values?: undefined): string;

    encodeFunctionData(
        functionFragment: 'nonfungiblePositionManager',
        values?: undefined
    ): string;

    encodeFunctionData(
        functionFragment: 'onERC721Received',
        values: [string, string, BigNumberish, BytesLike]
    ): string;

    encodeFunctionData(
        functionFragment: 'ownerOf',
        values: [BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'permit',
        values: [
            string,
            BigNumberish,
            BigNumberish,
            BigNumberish,
            BytesLike,
            BytesLike
        ]
    ): string;

    encodeFunctionData(
        functionFragment: 'processSwap',
        values?: undefined
    ): string;

    encodeFunctionData(
        functionFragment: 'safeTransferFrom',
        values: [string, string, BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'setApprovalForAll',
        values: [string, boolean]
    ): string;

    encodeFunctionData(
        functionFragment: 'setFarmingCenterAddress',
        values: [string, string]
    ): string;

    encodeFunctionData(
        functionFragment: 'supportsInterface',
        values: [BytesLike]
    ): string;

    encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;

    encodeFunctionData(
        functionFragment: 'tokenByIndex',
        values: [BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'tokenOfOwnerByIndex',
        values: [string, BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'tokenURI',
        values: [BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'totalSupply',
        values?: undefined
    ): string;

    encodeFunctionData(
        functionFragment: 'transferFrom',
        values: [string, string, BigNumberish]
    ): string;

    encodeFunctionData(
        functionFragment: 'virtualPoolAddresses',
        values: [string]
    ): string;

    encodeFunctionData(
        functionFragment: 'withdrawToken',
        values: [BigNumberish, string, BytesLike]
    ): string;

    decodeFunctionResult(
        functionFragment: 'DOMAIN_SEPARATOR',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'PERMIT_TYPEHASH',
        data: BytesLike
    ): Result;

    decodeFunctionResult(functionFragment: 'approve', data: BytesLike): Result;

    decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;

    decodeFunctionResult(functionFragment: 'baseURI', data: BytesLike): Result;

    decodeFunctionResult(
        functionFragment: 'claimReward',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'collectFees',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'collectRewards',
        data: BytesLike
    ): Result;

    decodeFunctionResult(functionFragment: 'cross', data: BytesLike): Result;

    decodeFunctionResult(functionFragment: 'deposits', data: BytesLike): Result;

    decodeFunctionResult(
        functionFragment: 'enterEternalFarming',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'enterFarming',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'eternalFarming',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'exitEternalFarming',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'exitFarming',
        data: BytesLike
    ): Result;

    decodeFunctionResult(functionFragment: 'farming', data: BytesLike): Result;

    decodeFunctionResult(
        functionFragment: 'getApproved',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'increaseCumulative',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'isApprovedForAll',
        data: BytesLike
    ): Result;

    decodeFunctionResult(functionFragment: 'l2Nfts', data: BytesLike): Result;

    decodeFunctionResult(functionFragment: 'multicall', data: BytesLike): Result;

    decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;

    decodeFunctionResult(
        functionFragment: 'nonfungiblePositionManager',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'onERC721Received',
        data: BytesLike
    ): Result;

    decodeFunctionResult(functionFragment: 'ownerOf', data: BytesLike): Result;

    decodeFunctionResult(functionFragment: 'permit', data: BytesLike): Result;

    decodeFunctionResult(
        functionFragment: 'processSwap',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'safeTransferFrom',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'setApprovalForAll',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'setFarmingCenterAddress',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'supportsInterface',
        data: BytesLike
    ): Result;

    decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;

    decodeFunctionResult(
        functionFragment: 'tokenByIndex',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'tokenOfOwnerByIndex',
        data: BytesLike
    ): Result;

    decodeFunctionResult(functionFragment: 'tokenURI', data: BytesLike): Result;

    decodeFunctionResult(
        functionFragment: 'totalSupply',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'transferFrom',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'virtualPoolAddresses',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'withdrawToken',
        data: BytesLike
    ): Result;

    getEvent(nameOrSignatureOrTopic: 'Approval'): EventFragment;

    getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;

    getEvent(nameOrSignatureOrTopic: 'DepositTransferred'): EventFragment;

    getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
}

export type ApprovalEvent = TypedEvent<[string, string, BigNumber] & {
    owner: string;
    approved: string;
    tokenId: BigNumber;
}>;

export type ApprovalForAllEvent = TypedEvent<[string, string, boolean] & {
    owner: string;
    operator: string;
    approved: boolean;
}>;

export type DepositTransferredEvent = TypedEvent<[BigNumber, string, string] & {
    tokenId: BigNumber;
    oldOwner: string;
    newOwner: string;
}>;

export type TransferEvent = TypedEvent<[string, string, BigNumber] & { from: string; to: string; tokenId: BigNumber }>;

export class FarmingCenter extends BaseContract {
    interface: FarmingCenterInterface
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

        PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

        approve(
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        balanceOf(owner: string, overrides?: CallOverrides): Promise<[BigNumber]>;

        baseURI(overrides?: CallOverrides): Promise<[string]>;

        claimReward(
            rewardToken: string,
            to: string,
            amountRequestedIncentive: BigNumberish,
            amountRequestedEternal: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        collectFees(
            params: {
                tokenId: BigNumberish;
                recipient: string;
                amount0Max: BigNumberish;
                amount1Max: BigNumberish;
            },
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        collectRewards(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        cross(
            nextTick: BigNumberish,
            zeroForOne: boolean,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        deposits(
            arg0: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[BigNumber, number, number, number, string] & {
            L2TokenId: BigNumber;
            tickLower: number;
            tickUpper: number;
            numberOfFarms: number;
            owner: string;
        }>;

        enterEternalFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        enterFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        eternalFarming(overrides?: CallOverrides): Promise<[string]>;

        exitEternalFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        exitFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        farming(overrides?: CallOverrides): Promise<[string]>;

        getApproved(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[string]>;

        increaseCumulative(
            blockTimestamp: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        isApprovedForAll(
            owner: string,
            operator: string,
            overrides?: CallOverrides
        ): Promise<[boolean]>;

        l2Nfts(
            arg0: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[BigNumber, string, BigNumber] & {
            nonce: BigNumber;
            operator: string;
            tokenId: BigNumber;
        }>;

        multicall(
            data: BytesLike[],
            overrides?: PayableOverrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        name(overrides?: CallOverrides): Promise<[string]>;

        nonfungiblePositionManager(overrides?: CallOverrides): Promise<[string]>;

        onERC721Received(
            arg0: string,
            from: string,
            tokenId: BigNumberish,
            arg3: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        ownerOf(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[string]>;

        permit(
            spender: string,
            tokenId: BigNumberish,
            deadline: BigNumberish,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
            overrides?: PayableOverrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        processSwap(
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        'safeTransferFrom(address,address,uint256)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        'safeTransferFrom(address,address,uint256,bytes)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            _data: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        setApprovalForAll(
            operator: string,
            approved: boolean,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        setFarmingCenterAddress(
            pool: string,
            virtualPool: string,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        supportsInterface(
            interfaceId: BytesLike,
            overrides?: CallOverrides
        ): Promise<[boolean]>;

        symbol(overrides?: CallOverrides): Promise<[string]>;

        tokenByIndex(
            index: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[BigNumber]>;

        tokenOfOwnerByIndex(
            owner: string,
            index: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[BigNumber]>;

        tokenURI(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[string]>;

        totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

        transferFrom(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        virtualPoolAddresses(
            arg0: string,
            overrides?: CallOverrides
        ): Promise<[string, string] & { virtualPool: string; eternalVirtualPool: string }>;

        withdrawToken(
            tokenId: BigNumberish,
            to: string,
            data: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;
    }
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

        PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

        approve(
            to: string,
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<void>;

        balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

        baseURI(overrides?: CallOverrides): Promise<string>;

        claimReward(
            rewardToken: string,
            to: string,
            amountRequestedIncentive: BigNumberish,
            amountRequestedEternal: BigNumberish,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        collectFees(
            params: {
                tokenId: BigNumberish;
                recipient: string;
                amount0Max: BigNumberish;
                amount1Max: BigNumberish;
            },
            overrides?: CallOverrides
        ): Promise<[BigNumber, BigNumber] & { amount0: BigNumber; amount1: BigNumber }>;

        collectRewards(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[BigNumber, BigNumber] & { reward: BigNumber; bonusReward: BigNumber }>;

        cross(
            nextTick: BigNumberish,
            zeroForOne: boolean,
            overrides?: CallOverrides
        ): Promise<void>;

        deposits(
            arg0: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[BigNumber, number, number, number, string] & {
            L2TokenId: BigNumber;
            tickLower: number;
            tickUpper: number;
            numberOfFarms: number;
            owner: string;
        }>;

        enterEternalFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<void>;

        enterFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<void>;

        eternalFarming(overrides?: CallOverrides): Promise<string>;

        exitEternalFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<void>;

        exitFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<void>;

        farming(overrides?: CallOverrides): Promise<string>;

        getApproved(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<string>;

        increaseCumulative(
            blockTimestamp: BigNumberish,
            overrides?: CallOverrides
        ): Promise<number>;

        isApprovedForAll(
            owner: string,
            operator: string,
            overrides?: CallOverrides
        ): Promise<boolean>;

        l2Nfts(
            arg0: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[BigNumber, string, BigNumber] & {
            nonce: BigNumber;
            operator: string;
            tokenId: BigNumber;
        }>;

        multicall(data: BytesLike[], overrides?: CallOverrides): Promise<string[]>;

        name(overrides?: CallOverrides): Promise<string>;

        nonfungiblePositionManager(overrides?: CallOverrides): Promise<string>;

        onERC721Received(
            arg0: string,
            from: string,
            tokenId: BigNumberish,
            arg3: BytesLike,
            overrides?: CallOverrides
        ): Promise<string>;

        ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

        permit(
            spender: string,
            tokenId: BigNumberish,
            deadline: BigNumberish,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
            overrides?: CallOverrides
        ): Promise<void>;

        processSwap(overrides?: CallOverrides): Promise<void>;

        'safeTransferFrom(address,address,uint256)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<void>;

        'safeTransferFrom(address,address,uint256,bytes)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            _data: BytesLike,
            overrides?: CallOverrides
        ): Promise<void>;

        setApprovalForAll(
            operator: string,
            approved: boolean,
            overrides?: CallOverrides
        ): Promise<void>;

        setFarmingCenterAddress(
            pool: string,
            virtualPool: string,
            overrides?: CallOverrides
        ): Promise<void>;

        supportsInterface(
            interfaceId: BytesLike,
            overrides?: CallOverrides
        ): Promise<boolean>;

        symbol(overrides?: CallOverrides): Promise<string>;

        tokenByIndex(
            index: BigNumberish,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        tokenOfOwnerByIndex(
            owner: string,
            index: BigNumberish,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        tokenURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

        transferFrom(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<void>;

        virtualPoolAddresses(
            arg0: string,
            overrides?: CallOverrides
        ): Promise<[string, string] & { virtualPool: string; eternalVirtualPool: string }>;

        withdrawToken(
            tokenId: BigNumberish,
            to: string,
            data: BytesLike,
            overrides?: CallOverrides
        ): Promise<void>;
    }
    filters: {
        'Approval(address,address,uint256)'(
            owner?: string | null,
            approved?: string | null,
            tokenId?: BigNumberish | null
        ): TypedEventFilter<[string, string, BigNumber],
            { owner: string; approved: string; tokenId: BigNumber }>;

        Approval(
            owner?: string | null,
            approved?: string | null,
            tokenId?: BigNumberish | null
        ): TypedEventFilter<[string, string, BigNumber],
            { owner: string; approved: string; tokenId: BigNumber }>;

        'ApprovalForAll(address,address,bool)'(
            owner?: string | null,
            operator?: string | null,
            approved?: null
        ): TypedEventFilter<[string, string, boolean],
            { owner: string; operator: string; approved: boolean }>;

        ApprovalForAll(
            owner?: string | null,
            operator?: string | null,
            approved?: null
        ): TypedEventFilter<[string, string, boolean],
            { owner: string; operator: string; approved: boolean }>;

        'DepositTransferred(uint256,address,address)'(
            tokenId?: BigNumberish | null,
            oldOwner?: string | null,
            newOwner?: string | null
        ): TypedEventFilter<[BigNumber, string, string],
            { tokenId: BigNumber; oldOwner: string; newOwner: string }>;

        DepositTransferred(
            tokenId?: BigNumberish | null,
            oldOwner?: string | null,
            newOwner?: string | null
        ): TypedEventFilter<[BigNumber, string, string],
            { tokenId: BigNumber; oldOwner: string; newOwner: string }>;

        'Transfer(address,address,uint256)'(
            from?: string | null,
            to?: string | null,
            tokenId?: BigNumberish | null
        ): TypedEventFilter<[string, string, BigNumber],
            { from: string; to: string; tokenId: BigNumber }>;

        Transfer(
            from?: string | null,
            to?: string | null,
            tokenId?: BigNumberish | null
        ): TypedEventFilter<[string, string, BigNumber],
            { from: string; to: string; tokenId: BigNumber }>;
    }
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

        PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

        approve(
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

        baseURI(overrides?: CallOverrides): Promise<BigNumber>;

        claimReward(
            rewardToken: string,
            to: string,
            amountRequestedIncentive: BigNumberish,
            amountRequestedEternal: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        collectFees(
            params: {
                tokenId: BigNumberish;
                recipient: string;
                amount0Max: BigNumberish;
                amount1Max: BigNumberish;
            },
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        collectRewards(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        cross(
            nextTick: BigNumberish,
            zeroForOne: boolean,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        deposits(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        enterEternalFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        enterFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        eternalFarming(overrides?: CallOverrides): Promise<BigNumber>;

        exitEternalFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        exitFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        farming(overrides?: CallOverrides): Promise<BigNumber>;

        getApproved(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        increaseCumulative(
            blockTimestamp: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        isApprovedForAll(
            owner: string,
            operator: string,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        l2Nfts(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        multicall(
            data: BytesLike[],
            overrides?: PayableOverrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        name(overrides?: CallOverrides): Promise<BigNumber>;

        nonfungiblePositionManager(overrides?: CallOverrides): Promise<BigNumber>;

        onERC721Received(
            arg0: string,
            from: string,
            tokenId: BigNumberish,
            arg3: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        ownerOf(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        permit(
            spender: string,
            tokenId: BigNumberish,
            deadline: BigNumberish,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
            overrides?: PayableOverrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        processSwap(
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        'safeTransferFrom(address,address,uint256)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        'safeTransferFrom(address,address,uint256,bytes)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            _data: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        setApprovalForAll(
            operator: string,
            approved: boolean,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        setFarmingCenterAddress(
            pool: string,
            virtualPool: string,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        supportsInterface(
            interfaceId: BytesLike,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        symbol(overrides?: CallOverrides): Promise<BigNumber>;

        tokenByIndex(
            index: BigNumberish,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        tokenOfOwnerByIndex(
            owner: string,
            index: BigNumberish,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        tokenURI(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

        transferFrom(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        virtualPoolAddresses(
            arg0: string,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        withdrawToken(
            tokenId: BigNumberish,
            to: string,
            data: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;
    }
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        approve(
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        balanceOf(
            owner: string,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        baseURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        claimReward(
            rewardToken: string,
            to: string,
            amountRequestedIncentive: BigNumberish,
            amountRequestedEternal: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        collectFees(
            params: {
                tokenId: BigNumberish;
                recipient: string;
                amount0Max: BigNumberish;
                amount1Max: BigNumberish;
            },
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        collectRewards(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        cross(
            nextTick: BigNumberish,
            zeroForOne: boolean,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        deposits(
            arg0: BigNumberish,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        enterEternalFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        enterFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        eternalFarming(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        exitEternalFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        exitFarming(
            key: {
                rewardToken: string;
                bonusRewardToken: string;
                pool: string;
                startTime: BigNumberish;
                endTime: BigNumberish;
            },
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        farming(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        getApproved(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        increaseCumulative(
            blockTimestamp: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        isApprovedForAll(
            owner: string,
            operator: string,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        l2Nfts(
            arg0: BigNumberish,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        multicall(
            data: BytesLike[],
            overrides?: PayableOverrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        nonfungiblePositionManager(
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        onERC721Received(
            arg0: string,
            from: string,
            tokenId: BigNumberish,
            arg3: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        ownerOf(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        permit(
            spender: string,
            tokenId: BigNumberish,
            deadline: BigNumberish,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
            overrides?: PayableOverrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        processSwap(
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        'safeTransferFrom(address,address,uint256)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        'safeTransferFrom(address,address,uint256,bytes)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            _data: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        setApprovalForAll(
            operator: string,
            approved: boolean,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        setFarmingCenterAddress(
            pool: string,
            virtualPool: string,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        supportsInterface(
            interfaceId: BytesLike,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        tokenByIndex(
            index: BigNumberish,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        tokenOfOwnerByIndex(
            owner: string,
            index: BigNumberish,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        tokenURI(
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        transferFrom(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        virtualPoolAddresses(
            arg0: string,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        withdrawToken(
            tokenId: BigNumberish,
            to: string,
            data: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;
    }

    connect(signerOrProvider: Signer | Provider | string): this;

    attach(addressOrName: string): this;

    deployed(): Promise<this>;

    listeners<EventArgsArray extends Array<any>, EventArgsObject>(
        eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
    ): Array<TypedListener<EventArgsArray, EventArgsObject>>;

    off<EventArgsArray extends Array<any>, EventArgsObject>(
        eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
        listener: TypedListener<EventArgsArray, EventArgsObject>
    ): this;

    on<EventArgsArray extends Array<any>, EventArgsObject>(
        eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
        listener: TypedListener<EventArgsArray, EventArgsObject>
    ): this;

    once<EventArgsArray extends Array<any>, EventArgsObject>(
        eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
        listener: TypedListener<EventArgsArray, EventArgsObject>
    ): this;

    removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
        eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
        listener: TypedListener<EventArgsArray, EventArgsObject>
    ): this;

    removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
        eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
    ): this;

    listeners(eventName?: string): Array<Listener>;

    off(eventName: string, listener: Listener): this;

    on(eventName: string, listener: Listener): this;

    once(eventName: string, listener: Listener): this;

    removeListener(eventName: string, listener: Listener): this;

    removeAllListeners(eventName?: string): this;

    queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
        event: TypedEventFilter<EventArgsArray, EventArgsObject>,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined
    ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    approve(
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

    baseURI(overrides?: CallOverrides): Promise<string>;

    claimReward(
        rewardToken: string,
        to: string,
        amountRequestedIncentive: BigNumberish,
        amountRequestedEternal: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    collectFees(
        params: {
            tokenId: BigNumberish;
            recipient: string;
            amount0Max: BigNumberish;
            amount1Max: BigNumberish;
        },
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    collectRewards(
        key: {
            rewardToken: string;
            bonusRewardToken: string;
            pool: string;
            startTime: BigNumberish;
            endTime: BigNumberish;
        },
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cross(
        nextTick: BigNumberish,
        zeroForOne: boolean,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    deposits(
        arg0: BigNumberish,
        overrides?: CallOverrides
    ): Promise<[BigNumber, number, number, number, string] & {
        L2TokenId: BigNumber;
        tickLower: number;
        tickUpper: number;
        numberOfFarms: number;
        owner: string;
    }>;

    enterEternalFarming(
        key: {
            rewardToken: string;
            bonusRewardToken: string;
            pool: string;
            startTime: BigNumberish;
            endTime: BigNumberish;
        },
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    enterFarming(
        key: {
            rewardToken: string;
            bonusRewardToken: string;
            pool: string;
            startTime: BigNumberish;
            endTime: BigNumberish;
        },
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    eternalFarming(overrides?: CallOverrides): Promise<string>;

    exitEternalFarming(
        key: {
            rewardToken: string;
            bonusRewardToken: string;
            pool: string;
            startTime: BigNumberish;
            endTime: BigNumberish;
        },
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    exitFarming(
        key: {
            rewardToken: string;
            bonusRewardToken: string;
            pool: string;
            startTime: BigNumberish;
            endTime: BigNumberish;
        },
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    farming(overrides?: CallOverrides): Promise<string>;

    getApproved(
        tokenId: BigNumberish,
        overrides?: CallOverrides
    ): Promise<string>;

    increaseCumulative(
        blockTimestamp: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    isApprovedForAll(
        owner: string,
        operator: string,
        overrides?: CallOverrides
    ): Promise<boolean>;

    l2Nfts(
        arg0: BigNumberish,
        overrides?: CallOverrides
    ): Promise<[BigNumber, string, BigNumber] & {
        nonce: BigNumber;
        operator: string;
        tokenId: BigNumber;
    }>;

    multicall(
        data: BytesLike[],
        overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<string>;

    nonfungiblePositionManager(overrides?: CallOverrides): Promise<string>;

    onERC721Received(
        arg0: string,
        from: string,
        tokenId: BigNumberish,
        arg3: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

    permit(
        spender: string,
        tokenId: BigNumberish,
        deadline: BigNumberish,
        v: BigNumberish,
        r: BytesLike,
        s: BytesLike,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    processSwap(
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'safeTransferFrom(address,address,uint256)'(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'safeTransferFrom(address,address,uint256,bytes)'(
        from: string,
        to: string,
        tokenId: BigNumberish,
        _data: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setApprovalForAll(
        operator: string,
        approved: boolean,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setFarmingCenterAddress(
        pool: string,
        virtualPool: string,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    supportsInterface(
        interfaceId: BytesLike,
        overrides?: CallOverrides
    ): Promise<boolean>;

    symbol(overrides?: CallOverrides): Promise<string>;

    tokenByIndex(
        index: BigNumberish,
        overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenOfOwnerByIndex(
        owner: string,
        index: BigNumberish,
        overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transferFrom(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    virtualPoolAddresses(
        arg0: string,
        overrides?: CallOverrides
    ): Promise<[string, string] & { virtualPool: string; eternalVirtualPool: string }>;

    withdrawToken(
        tokenId: BigNumberish,
        to: string,
        data: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
}
